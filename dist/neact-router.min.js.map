{"version":3,"sources":["../node_modules/path-to-regexp/index.js","../node_modules/object-assign/index.js","../src/shared.js","../node_modules/warning/warning.js","../node_modules/path-to-regexp/node_modules/isarray/index.js","../src/matchPath.js","../src/Route.js","../src/Router.js","../src/Link.js","../src/Switch.js","../src/NavLink.js","../src/Redirect.js"],"names":["parse","str","options","res","tokens","key","index","path","defaultDelimiter","delimiter","PATH_REGEXP","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toString","toUpperCase","encodeAsterisk","matches","Array","i","babelHelpers['typeof']","RegExp","obj","opts","data","encode","pretty","encodeURIComponent","token","segment","value","TypeError","isarray","JSON","stringify","j","test","attachKeys","re","keys","flags","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","parts","pathToRegexp","join","stringToRegexp","tokensToRegExp","strict","end","route","endsWithDelimiter","toObject","val","undefined","Object","isUndefined","isNull","isNullOrUndef","isObject","o","_typeof","trimDots","ary","part","splice","normalizeUrl","baseName","arguments","baseParts","split","charAt","concat","warning","warning_1","index$1","isArray","arr","prototype","call","parse_1","compile_1","tokensToFunction_1","tokensToRegExp_1","patternCache","cacheCount","compilePath","cacheKey","cache","compiledPattern","matchPath","pathname","_options$path","exact","_options$exact","_options$strict","_compilePath","url","_match","values","isExact","reduce","memo","getOwnPropertySymbols","hasOwnProperty","propIsEnumerable","propertyIsEnumerable","index$3","assign","test1","String","getOwnPropertyNames","test2","fromCharCode","map","n","test3","forEach","letter","err","target","from","symbols","to","s","objToString","Route","Neact","props","context","normalizePath","state","this","computeMatch","router","_ref","_ref2","location","computedMatch","_assign","component","_props","render","children","nextProps","nextContext","setState","_props2","history","_context$router","staticContext","only","Router","unlisten","listen","_this","isModifiedEvent","event","metaKey","altKey","ctrlKey","shiftKey","Link","onClick","defaultPrevented","button","preventDefault","baseUrl","objectWithoutProperties","href","createHref","e","handleClick","defaultProps","Switch","child","element","pathProp","_element$props","NavLink","activeClassName","className","activeStyle","style","getIsActive","isActive","rest","Redirect","isStatic","perform","displayName"],"mappings":"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","file":"neact-router.min.js","sourcesContent":["var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","'use strict';\r\n\r\nvar objToString = Object.prototype.toString;\r\n\r\nexport var isArray = Array.isArray || function(s) {\r\n    return objToString.call(s) === '[object Array]';\r\n};\r\n\r\nexport function isUndefined(obj) {\r\n    return obj === undefined;\r\n}\r\n\r\nexport function isNull(obj) {\r\n    return obj === null;\r\n}\r\n\r\nexport function isNullOrUndef(obj) {\r\n    return isUndefined(obj) || isNull(obj);\r\n}\r\n\r\nexport function isObject(o) {\r\n    return typeof o === 'object';\r\n}\r\n\r\nfunction trimDots(ary) {\r\n    let i, part;\r\n    for (i = 0; i < ary.length; i++) {\r\n        part = ary[i];\r\n\r\n        if (part === '' && i > 0 || part === '.') {\r\n            ary.splice(i, 1);\r\n            i -= 1;\r\n        } else if (part === '..') {\r\n            if (i === 0) {\r\n                ary.splice(0, 1);\r\n                i = -1;\r\n            } else if (i === 1 && ary[0] === '') {\r\n                ary.splice(i, 1);\r\n                i -= 1;\r\n            } else {\r\n                ary.splice(i - 1, 2);\r\n                i -= 2;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function normalizeUrl(path, baseName = '/', delimiter = '/') {\r\n    const baseParts = baseName.split(delimiter);\r\n\r\n    if (isUndefined(path)) { return path; }\r\n\r\n    if (path) {\r\n        path = path.split(delimiter);\r\n\r\n        if (path[0].charAt(0) === '.' || path[0] !== '') {\r\n            path = baseParts.concat(path);\r\n        }\r\n\r\n        trimDots(path);\r\n\r\n        if (path.length === 1 && path[0] === '') {\r\n            path.push('');\r\n        }\r\n\r\n        path = path.join(delimiter);\r\n    } else {\r\n        path = baseName + path;\r\n    }\r\n\r\n    return path;\r\n}","/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","'use strict';\r\n\r\nimport pathToRegexp from 'path-to-regexp';\r\n\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\nlet cacheCount = 0;\r\n\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n\r\n    if (cache[pattern]) {\r\n        return cache[pattern];\r\n    }\r\n\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n\r\n    if (cacheCount < cacheLimit) {\r\n        cache[pattern] = compiledPattern;\r\n        cacheCount++;\r\n    }\r\n\r\n    return compiledPattern;\r\n};\r\n\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nconst matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options }\r\n    }\r\n\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n\r\n    if (!match) {\r\n        return null;\r\n    }\r\n\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        path, // the path pattern used to match\r\n        url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL\r\n        isExact, // whether or not we matched exactly\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {})\r\n    }\r\n}\r\n\r\nexport default matchPath;","'use strict';\r\n\r\nimport warning from 'warning';\r\nimport * as Neact from 'neact';\r\nimport matchPath from './matchPath';\r\n\r\nimport _assign from 'object-assign';\r\n\r\nimport {\r\n    isArray,\r\n    normalizeUrl\r\n} from './shared';\r\n\r\nconst Route = Neact.createClass({\r\n    construct(props, context) {\r\n        this.normalizePath(props, context);\r\n\r\n        this.state.match = this.computeMatch(props, context.router);\r\n    },\r\n\r\n    normalizePath(props, context) {\r\n        const router = context.router;\r\n        const baseUrl = router.route.match ? router.route.match.url : '/';\r\n\r\n        props.path = normalizeUrl(props.path, baseUrl);\r\n    },\r\n\r\n    computeMatch({ location, path, strict, exact, computedMatch }, { route }) {\r\n        if (computedMatch) {\r\n            return computedMatch;\r\n        }\r\n\r\n        const pathname = (location || route.location).pathname;\r\n\r\n        return path ? matchPath(pathname, { path, strict, exact }) : route.match;\r\n    },\r\n\r\n    getChildContext() {\r\n        return {\r\n            router: _assign({}, this.context.router, {\r\n                route: {\r\n                    location: this.props.location || this.context.router.route.location,\r\n                    match: this.state.match\r\n                }\r\n            })\r\n        };\r\n    },\r\n\r\n    componentWillMount() {\r\n        const { component, render, children } = this.props;\r\n\r\n        warning(!(component && render),\r\n            'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored'\r\n        );\r\n\r\n        warning(!(component && children),\r\n            'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored'\r\n        );\r\n\r\n        warning(!(render && children),\r\n            'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored'\r\n        );\r\n    },\r\n\r\n    componentWillReceiveProps(nextProps, nextContext) {\r\n        warning(!(nextProps.location && !this.props.location),\r\n            '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\r\n        );\r\n\r\n        warning(!(!nextProps.location && this.props.location),\r\n            '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\r\n        );\r\n\r\n        this.normalizePath(nextProps, nextContext);\r\n\r\n        this.setState({\r\n            match: this.computeMatch(nextProps, nextContext.router)\r\n        });\r\n    },\r\n\r\n    render() {\r\n        const { match } = this.state;\r\n        const { children, component, render } = this.props;\r\n        const { history, route, staticContext } = this.context.router;\r\n        const location = this.props.location || route.location;\r\n        const props = { match, location, history, staticContext };\r\n\r\n        return (\r\n            component ? ( // component prop gets first priority, only called if there's a match\r\n                match ? Neact.createElement(component, props, children) : null\r\n            ) : render ? ( // render prop is next, only called if there's a match\r\n                match ? render(props) : null\r\n            ) : children ? ( // children come last, always called\r\n                typeof children === 'function' ? (\r\n                    children(props)\r\n                ) : !isArray(children) || children.length ? ( // Preact defaults to empty children array\r\n                    Neact.cloneElement(Neact.Children.only(children))\r\n                ) : (\r\n                    null\r\n                )\r\n            ) : (\r\n                null\r\n            )\r\n        )\r\n    }\r\n});\r\n\r\nexport default Route;","'use strict';\r\n\r\nimport warning from 'warning';\r\nimport * as Neact from 'neact';\r\n\r\nimport _assign from 'object-assign';\r\n\r\nconst Router = Neact.createClass({\r\n    construct(props) {\r\n        if (!props.history) {\r\n            throw new TypeError('history must be required!');\r\n        }\r\n\r\n        this.state.match = this.computeMatch(props.history.location.pathname);\r\n    },\r\n\r\n    getChildContext() {\r\n        return {\r\n            router: _assign({}, this.context.router, {\r\n                history: this.props.history,\r\n                route: {\r\n                    location: this.props.history.location,\r\n                    match: this.state.match\r\n                }\r\n            })\r\n        };\r\n    },\r\n\r\n    computeMatch(pathname) {\r\n        return {\r\n            path: '/',\r\n            url: '/',\r\n            params: {},\r\n            isExact: pathname === '/'\r\n        };\r\n    },\r\n\r\n    render() {\r\n        const { children } = this.props;\r\n        return children ? Neact.cloneElement(Neact.Children.only(children)) : null;\r\n    },\r\n\r\n    componentWillMount() {\r\n        const { children, history } = this.props;\r\n\r\n        this.unlisten = history.listen(() => {\r\n            this.setState({\r\n                match: this.computeMatch(history.location.pathname)\r\n            });\r\n        });\r\n    },\r\n\r\n    componentWillReceiveProps(nextProps) {\r\n        warning(\r\n            this.props.history === nextProps.history,\r\n            'You cannot change <Router history>'\r\n        );\r\n    },\r\n\r\n    componentWillUnmount() {\r\n        this.unlisten();\r\n    }\r\n});\r\n\r\nexport default Router;","'use strict';\r\n\r\nimport * as Neact from 'neact';\r\nimport _assign from 'object-assign';\r\nimport {\r\n    normalizeUrl\r\n} from './shared';\r\n\r\nconst isModifiedEvent = (event) =>\r\n    !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)\r\n\r\nconst Link = Neact.createClass({\r\n    handleClick(event) {\r\n        if (this.props.onClick) {\r\n            this.props.onClick(event);\r\n        }\r\n\r\n        if (!event.defaultPrevented && // onClick prevented default\r\n            event.button === 0 && // ignore right clicks\r\n            !this.props.target && // let browser handle \"target=_blank\" etc.\r\n            !isModifiedEvent(event) // ignore clicks with modifier keys\r\n        ) {\r\n            event.preventDefault();\r\n\r\n            const { history, route } = this.context.router;\r\n            const baseUrl = route.match ? route.match.url : '/';\r\n            let { replace, to } = this.props;\r\n\r\n            if (typeof to === 'string') {\r\n                to = { pathname: to };\r\n            }\r\n\r\n            to.pathname = normalizeUrl(to.pathname || '/', baseUrl);\r\n\r\n            if (replace) {\r\n                history.replace(to);\r\n            } else {\r\n                history.push(to);\r\n            }\r\n        }\r\n    },\r\n\r\n    render() {\r\n        let { replace, to, ...props } = this.props;\r\n        const baseUrl = this.context.router.route.match ? this.context.router.route.match.url : '/';\r\n\r\n        if (typeof to === 'string') {\r\n            to = { pathname: to };\r\n        }\r\n\r\n        to.pathname = normalizeUrl(to.pathname || '/', baseUrl);\r\n\r\n        const href = this.context.router.history.createHref(\r\n            typeof to === 'string' ? { pathname: to } : to\r\n        );\r\n\r\n        return Neact.createElement('a', _assign({}, props, {\r\n            onClick: (e) => this.handleClick(e),\r\n            href: href\r\n        }));\r\n    }\r\n\r\n});\r\n\r\nLink.defaultProps = {\r\n    replace: false\r\n};\r\n\r\nexport default Link;","'use strict';\r\n\r\nimport * as Neact from 'neact';\r\nimport warning from 'warning';\r\nimport matchPath from './matchPath';\r\nimport _assign from 'object-assign';\r\nimport {\r\n    isNullOrUndef,\r\n    normalizeUrl\r\n} from './shared';\r\n\r\nconst Switch = Neact.createClass({\r\n    componentWillReceiveProps(nextProps) {\r\n        warning(!(nextProps.location && !this.props.location),\r\n            '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\r\n        );\r\n\r\n        warning(!(!nextProps.location && this.props.location),\r\n            '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\r\n        );\r\n    },\r\n\r\n    render() {\r\n        const { route } = this.context.router;\r\n        const { children } = this.props;\r\n        const location = this.props.location || route.location;\r\n        const baseName = route.match ? route.match.url : '/';\r\n\r\n        let match, child;\r\n        Neact.Children.forEach(children, element => {\r\n            if (!Neact.isValidElement(element)) { return; }\r\n\r\n            const { path: pathProp, exact, strict, from } = element.props;\r\n            let path = pathProp || from;\r\n\r\n            if (isNullOrUndef(match)) {\r\n                child = element;\r\n                match = path ? matchPath(location.pathname, { path: normalizeUrl(path, baseName), exact, strict }) : route.match;\r\n            }\r\n        });\r\n\r\n        child.props = _assign(child.props || (child.props = {}), { location, computedMatch: match })\r\n\r\n        return match ? child : null;\r\n    }\r\n});\r\n\r\nexport default Switch;","'use strict';\r\n\r\nimport * as Neact from 'neact';\r\nimport {\r\n    isObject\r\n} from './shared';\r\n\r\nimport _assign from 'object-assign';\r\n\r\nimport Route from './Route';\r\nimport Link from './Link';\r\n\r\n\r\nconst NavLink = ({\r\n    to,\r\n    exact,\r\n    strict,\r\n    activeClassName,\r\n    className,\r\n    activeStyle,\r\n    style,\r\n    isActive: getIsActive,\r\n    ...rest\r\n}) => (\r\n    Neact.createElement(Route, {\r\n        path: isObject(to) ? to.pathname : to,\r\n        exact,\r\n        strict,\r\n        children: ({ location, match }) => {\r\n            const isActive = !!(getIsActive ? getIsActive(match, location) : match);\r\n\r\n            return Neact.createElement(Link, _assign({}, rest, {\r\n                to,\r\n                className: isActive ? [activeClassName, className].join(' ') : className,\r\n                style: isActive ? _assign({}, style, activeStyle) : style\r\n            }));\r\n        }\r\n    })\r\n);\r\n\r\nNavLink.defaultProps = {\r\n    activeClassName: 'active'\r\n};\r\n\r\nexport default NavLink;","'use strict';\r\n\r\nimport * as Neact from 'neact';\r\n\r\nconst Redirect = Neact.createClass({\r\n    isStatic() {\r\n        return this.context.router && this.context.router.staticContext;\r\n    },\r\n\r\n\r\n    componentWillMount() {\r\n        if (this.isStatic()) {\r\n            this.perform();\r\n        }\r\n    },\r\n\r\n    componentDidMount() {\r\n        if (!this.isStatic()) {\r\n            this.perform();\r\n        }\r\n    },\r\n\r\n    perform() {\r\n        const { history } = this.context.router;\r\n        const { push, to } = this.props;\r\n        //setTimeout(() => {\r\n\r\n        if (push) {\r\n            history.push(to);\r\n        } else {\r\n            history.replace(to);\r\n        }\r\n        //}, 0);\r\n    },\r\n\r\n    render() {\r\n        return null;\r\n    }\r\n});\r\n\r\nRedirect.displayName = \"Redirect\";\r\n\r\nRedirect.defaultProps = {\r\n    push: false\r\n};\r\n\r\nexport default Redirect;"]}